"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react/jsx-runtime"),t=require("react");const r=(e,r,n,s={})=>{const l={root:null,rootMargin:"0px",threshold:.1},a=t.useRef(null),u=t.useRef(new Map),c=t.useMemo((()=>Object.assign(Object.assign({},l),s)),[s]),i=t.useCallback(null!=r?r:()=>{},[r]),o=t.useCallback(null!=n?n:()=>{},[n]);t.useEffect((()=>(a.current&&a.current.disconnect(),a.current=new IntersectionObserver((e=>{e.forEach((e=>{o(e);const t=u.current.get(e.target),r=e.isIntersecting;t!==r&&(u.current.set(e.target,r),i(r,e))}))}),c),e&&e.forEach((e=>{var t;e&&(null===(t=a.current)||void 0===t||t.observe(e))})),()=>{a.current&&a.current.disconnect()})),[e,c,i,o,u]);return{observe:t.useCallback((e=>{a.current&&e&&a.current.observe(e)}),[]),unobserve:t.useCallback((e=>{a.current&&e&&a.current.unobserve(e)}),[])}},n=({item:r,isVisible:n,refreshOnVisible:s,fetchItemData:l,children:a,itemLoader:u})=>{const[c,i]=t.useState(null),o=t.useRef(!1);return t.useEffect((()=>{l&&n&&(s||!o.current)&&l(r).then((e=>{i(e),o.current=!0}))}),[n,s,l,r]),e.jsx(e.Fragment,{children:n?a(r,c):u})};exports.default=({listData:s=[],renderItem:l=(t=>e.jsx(e.Fragment,{children:t||"Loading data..."})),refreshOnVisible:a=!1,fetchItemData:u=null,containerHeight:c="400px",itemStyle:i={},listClassName:o=null,itemClassName:d=null,observerOptions:h={root:null,rootMargin:"0px",threshold:.1},onLoadMore:b=(()=>Promise.resolve()),hasMore:g=!1,loader:f="",endMessage:m="",itemLoader:v="",emptyListMessage:x=null})=>{const[j,p]=t.useState(new Set),[M,O]=t.useState(!1),C=t.useRef([]),I=t.useRef(null),k=t.useCallback(((e,t)=>{const r=parseInt(t.target.getAttribute("data-index"),10);p((t=>{const n=new Set(t);return e?n.add(r):n.delete(r),n}))}),[]),y=t.useCallback((e=>{e&&g&&!M&&(O(!0),b().finally((()=>{O(!1)})))}),[g,b,M]),{observe:E,unobserve:L}=r(C.current,k,null,h);r([I.current],y,null,{root:null,rootMargin:"0px",threshold:1});const S=t.useMemo((()=>{const e=[...j].sort(((e,t)=>e-t)),t=e[0]||0,r=e[e.length-1]||0;return[Math.max(0,t-2),Math.min(s.length-1,r+2)]}),[j,s.length]);t.useEffect((()=>{C.current.forEach(((e,t)=>{e&&(t<S[0]||t>S[1])&&(L(e),C.current[t]=null)}))}),[S,L]);const w=t.useCallback(((e,t)=>{e?(C.current[t]=e,E(e)):C.current[t]&&(L(C.current[t]),C.current[t]=null)}),[E,L]),R=t.useMemo((()=>Object.assign({},i)),[i]);return e.jsxs("div",Object.assign({className:o||void 0,style:{height:c,overflowY:"auto"}},{children:[s.length?s.map(((t,r)=>r>=S[0]&&r<=S[1]?e.jsx("div",Object.assign({className:d||void 0,style:R,ref:e=>w(e,r),"data-index":r},{children:e.jsx(n,Object.assign({item:s[r],isVisible:j.has(r),refreshOnVisible:a,fetchItemData:u,itemLoader:v},{children:l}))}),r):null)):x||null,s.length?g?e.jsx("div",Object.assign({ref:I,style:{height:"1px"}},{children:f})):e.jsx("div",{children:m}):null]}))},exports.useIntersectionObserver=r;
