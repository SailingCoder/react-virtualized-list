"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("react");const t=function(t,r,n){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const s={root:null,rootMargin:"0px",threshold:.1},a=e.useRef(null),u=e.useRef(new Map),c=e.useMemo((()=>({...s,...l})),[l]),o=e.useCallback(r,[r]),i=e.useCallback(n,[n]);e.useEffect((()=>(a.current&&a.current.disconnect(),a.current=new IntersectionObserver((e=>{e.forEach((e=>{i&&i(e);const t=u.current.get(e.target),r=e.isIntersecting;t!==r&&(u.current.set(e.target,r),o&&o(r,e))}))}),c),t&&t.forEach((e=>{e&&a.current.observe(e)})),()=>{a.current&&a.current.disconnect()})),[t,o,i,c]);return{observe:e.useCallback((e=>{a.current&&e&&a.current.observe(e)}),[]),unobserve:e.useCallback((e=>{a.current&&e&&a.current.unobserve(e)}),[])}},r=t=>{let{item:r,isVisible:n,refreshOnVisible:l,fetchItemData:s,children:a,itemLoader:u}=t;const[c,o]=e.useState(null),i=e.useRef(!1);return e.useEffect((()=>{s&&n&&(l||!i.current)&&s(r).then((e=>{o(e),i.current=!0}))}),[n,l,r]),e.createElement(e.Fragment,null,n?a(r,c):u)};exports.default=n=>{let{listData:l=[],renderItem:s=(t=>e.createElement(e.Fragment,null,t||"Loading data...")),refreshOnVisible:a=!1,fetchItemData:u=null,containerHeight:c="400px",itemStyle:o={},listClassName:i=null,itemClassName:h=null,observerOptions:m={root:null,rootMargin:"0px",threshold:.1},onLoadMore:d=(()=>{}),hasMore:f=!1,loader:b="",endMessage:g="",itemLoader:v="",emptyListMessage:p=null}=n;const[M,E]=e.useState(new Set),[x,C]=e.useState(!1),k=e.useRef([]),y=e.useRef(null),I=e.useCallback(((e,t)=>{const r=parseInt(t.target.getAttribute("data-index"),10);E(e?e=>new Set(e).add(r):e=>{const t=new Set(e);return t.delete(r),t})}),[]),{observe:O,unobserve:S}=t(k.current,I,null,m),w=e.useCallback((e=>{e&&f&&d&&!x&&(C(!0),d().finally((()=>{C(!1)})))}),[f,d,x]);t([y.current],w,null,{root:null,rootMargin:"0px",threshold:1});const L=e.useMemo((()=>{const e=[...M].sort(((e,t)=>e-t));if(0===e.length)return[0,2];const t=e[0],r=e[e.length-1];return[Math.max(0,t-2),Math.min(l.length-1,r+2)]}),[M,l.length]);e.useEffect((()=>{k.current.forEach(((e,t)=>{e&&(t<L[0]||t>L[1])&&(S(e),k.current[t]=null)}))}),[L,S]);const R=e.useCallback(((e,t)=>{e?(k.current[t]=e,O(e)):k.current[t]&&(S(k.current[t]),k.current[t]=null)}),[O,S]),V=e.useMemo((()=>({...o})),[o]);return e.createElement("div",{className:i,style:{height:c,overflowY:"auto"}},l.length?l.map(((t,n)=>n>=L[0]&&n<=L[1]?e.createElement("div",{className:h,style:V,ref:e=>R(e,n),key:n,"data-index":n},e.createElement(r,{item:l[n],isVisible:M.has(n),refreshOnVisible:a,fetchItemData:u,itemLoader:v},s)):null)):p||null,l.length?f?e.createElement("div",{ref:y,style:{height:"1px"}},b):e.createElement("div",null,g):null)},exports.useIntersectionObserver=t;
